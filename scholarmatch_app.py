# -*- coding: utf-8 -*-
"""scholarMatch_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v4KGBEJjg1eOZyx7Lg1aFDMWBJE1assM
"""
import streamlit as st
import pandas as pd
import sqlite3
from datetime import datetime
import json
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# ============================================================================
# PAGE CONFIGURATION
# ============================================================================

st.set_page_config(
    page_title="OptiScholar - Find Your Perfect Scholarship",
    page_icon="ğŸ“",
    layout="wide"
)

# ============================================================================
# MATCHING ENGINE (INTEGRATED)
# ============================================================================

def check_gpa_hard_requirement(student_cgpa, scholarship_min_gpa):
    if scholarship_min_gpa == -1:
        return True, "No GPA requirement"
    if student_cgpa >= scholarship_min_gpa:
        return True, f"GPA {student_cgpa:.2f} meets minimum {scholarship_min_gpa:.2f}"
    return False, f"GPA {student_cgpa:.2f} below minimum {scholarship_min_gpa:.2f}"

def check_degree_hard_requirement(student, scholarship):
    student_bachelor = student.get('is_bachelor', 0)
    student_master = student.get('is_master', 0)
    student_phd = student.get('is_phd', 0)
    schol_bachelor = scholarship.get('eligible_bachelor', 0)
    schol_master = scholarship.get('eligible_master', 0)
    schol_phd = scholarship.get('eligible_phd', 0)
    
    if student_bachelor and schol_bachelor:
        return True, "Degree level matches: Bachelor"
    if student_master and schol_master:
        return True, "Degree level matches: Master"
    if student_phd and schol_phd:
        return True, "Degree level matches: PhD"
    
    if schol_bachelor or schol_master or schol_phd:
        return False, "Degree level mismatch"
    
    return True, "No degree restriction"

def check_special_hard_requirements(student, scholarship):
    special_req = scholarship.get('special_eligibility', [])
    if not special_req or special_req in [['no_special_requirement'], ['unknown']]:
        return True, "No special requirements", 0
    if 'women_only' in special_req:
        if student.get('is_female', 0) == 1:
            return True, "Matches women-only scholarship", 20
        return False, "Does not meet women-only requirement", 0
    return True, "Special requirements unclear", 5

def check_explicit_exclusions(student, scholarship_description):
    if not scholarship_description or scholarship_description == '[MISSING_DESCRIPTION]':
        return True, "No exclusion detected", 100
    desc = scholarship_description.lower()
    student_program = student.get('program', '').lower()
    patterns = [r'not\s+for\s+', r'excluding\s+', r'except\s+']
    for p in patterns:
        if re.search(p, desc) and student_program in desc:
            return True, "Possible exclusion detected", 30
    return True, "No explicit exclusion", 100

def extract_field_restrictions(desc):
    if not desc or desc == '[MISSING_DESCRIPTION]':
        return None, 100
    desc = desc.lower()
    field_keywords = {
        'computer_science': ['computer science', 'cs students'],
        'engineering': ['engineering'],
        'business': ['business', 'mba'],
        'medicine': ['medical', 'medicine']
    }
    for field, keys in field_keywords.items():
        for k in keys:
            if f'{k} students only' in desc or f'for {k}' in desc:
                return field, 100
    return None, 100

def check_field_hard_match(student, scholarship_description):
    required_field, conf = extract_field_restrictions(scholarship_description)
    if required_field is None:
        return True, "No field restriction", 100
    program = student.get('program', '').lower()
    if required_field in program:
        return True, f"Matches field restriction ({required_field})", 100
    return False, f"Does not match field restriction ({required_field})", conf

def calculate_tfidf_similarity(student_profile, scholarship_desc, vectorizer):
    if not scholarship_desc or not student_profile:
        return 0.5, 50
    student_vec = vectorizer.transform([student_profile])
    schol_vec = vectorizer.transform([scholarship_desc])
    sim = cosine_similarity(student_vec, schol_vec)[0][0]
    confidence = 90 if len(scholarship_desc.split()) > 50 else 60
    return sim, confidence

def calculate_field_alignment_soft(student, scholarship, vectorizer):
    profile = f"{student.get('interest_area','')} {student.get('skills','')}".strip()
    desc = scholarship.get('description_cleaned', '')
    sim, conf = calculate_tfidf_similarity(profile, desc, vectorizer)
    return sim * 100, conf

def calculate_overall_confidence(confidences):
    if not confidences:
        return 50
    return min(confidences)

def calculate_gpa_strength_score(student_cgpa, min_gpa):
    if min_gpa == -1:
        return (student_cgpa / 4.0) * 100
    margin = max(student_cgpa - min_gpa, 0)
    return min((margin / 0.5) * 100, 100)

def calculate_financial_need_score(student_need, requires_need):
    if requires_need == 0:
        return 50
    return {'high_need': 100, 'medium_need': 70, 'low_need': 40}.get(student_need, 50)

def calculate_win_probability(student, scholarship, field_alignment, special_bonus):
    gpa_score = calculate_gpa_strength_score(
        student['current_cgpa'],
        scholarship['min_gpa_required']
    )
    field_score = field_alignment
    need_score = calculate_financial_need_score(
        student.get('financial_need_level', 'unknown'),
        scholarship.get('requires_financial_need', 0)
    )
    base_score = (
        0.45 * gpa_score +
        0.35 * field_score +
        0.20 * need_score
    )
    win_prob = min(base_score + special_bonus, 100)
    return {
        'win_probability': round(win_prob, 1),
        'gpa_score': round(gpa_score, 1),
        'field_score': round(field_score, 1),
        'special_score': special_bonus,
        'need_score': round(need_score, 1)
    }

def evaluate_scholarship_match(student, scholarship, vectorizer):
    reasons = []
    confs = []
    
    gpa_pass, gpa_reason = check_gpa_hard_requirement(
        student['current_cgpa'], scholarship['min_gpa_required']
    )
    if not gpa_pass:
        return False, None, 0, [gpa_reason]
    reasons.append(gpa_reason)
    
    deg_pass, deg_reason = check_degree_hard_requirement(student, scholarship)
    if not deg_pass:
        return False, None, 0, [deg_reason]
    reasons.append(deg_reason)
    
    sp_pass, sp_reason, sp_bonus = check_special_hard_requirements(student, scholarship)
    if not sp_pass:
        return False, None, 0, [sp_reason]
    reasons.append(sp_reason)
    
    ex_pass, ex_reason, ex_conf = check_explicit_exclusions(
        student, scholarship.get('description_cleaned', '')
    )
    reasons.append(ex_reason)
    confs.append(ex_conf)
    
    fh_pass, fh_reason, fh_conf = check_field_hard_match(
        student, scholarship.get('description_cleaned', '')
    )
    if not fh_pass:
        return False, None, 0, [fh_reason]
    reasons.append(fh_reason)
    confs.append(fh_conf)
    
    field_score, field_conf = calculate_field_alignment_soft(
        student, scholarship, vectorizer
    )
    confs.append(field_conf)
    
    confidence = calculate_overall_confidence(confs)
    
    scores = calculate_win_probability(
        student, scholarship, field_score, sp_bonus
    )
    
    return True, scores, confidence, reasons

def calculate_final_score(win_probability, confidence):
    return 0.7 * win_probability + 0.3 * confidence

def recommend_scholarships(student, scholarships_df, top_k=10):
    vectorizer = TfidfVectorizer(max_features=100, stop_words='english')
    vectorizer.fit(scholarships_df['description_cleaned'].fillna(''))
    
    recs = []
    for idx, schol in scholarships_df.iterrows():
        eligible, scores, conf, reasons = evaluate_scholarship_match(
            student, schol, vectorizer
        )
        if not eligible:
            continue
        
        final_score = calculate_final_score(scores['win_probability'], conf)
        
        recs.append({
            'scholarship_id': schol.get('scholarship_id', idx),
            'scholarship_title': schol.get('scholarship_title', 'Unknown'),
            'final_score': round(final_score, 1),
            'win_probability': scores['win_probability'],
            'confidence': round(conf, 1),
            'gpa_score': scores['gpa_score'],
            'field_score': scores['field_score'],
            'special_score': scores['special_score'],
            'need_score': scores['need_score'],
            'funding_amount': schol.get('funding_amount_raw', 'Unknown'),
            'funding_category': schol.get('funding_category', 'Unknown'),
            'deadline': schol.get('deadline', 'Unknown'),
            'deadline_urgency': schol.get('deadline_urgency', 'unknown'),
            'reasons': ' | '.join(reasons),
            'link': schol.get('link', '')
        })
    
    df = pd.DataFrame(recs)
    if len(df) == 0:
        return df
    return df.sort_values('final_score', ascending=False).head(top_k)

# ============================================================================
# DATABASE SETUP
# ============================================================================

def init_database():
    """Initialize SQLite database for feedback storage"""
    conn = sqlite3.connect('scholarMatch_feedback.db')
    c = conn.cursor()
    
    # Create feedback table
    c.execute('''
        CREATE TABLE IF NOT EXISTS feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            student_profile TEXT,
            scholarship_id TEXT,
            scholarship_title TEXT,
            win_probability REAL,
            confidence REAL,
            feedback_action TEXT,
            feedback_reason TEXT,
            additional_comments TEXT
        )
    ''')
    
    conn.commit()
    conn.close()

def save_feedback(student_profile, scholarship, feedback_action, feedback_reason=None, comments=None):
    """Save user feedback to database"""
    conn = sqlite3.connect('scholarMatch_feedback.db')
    c = conn.cursor()
    
    c.execute('''
        INSERT INTO feedback (
            timestamp, student_profile, scholarship_id, scholarship_title,
            win_probability, confidence, feedback_action, feedback_reason, additional_comments
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (
        datetime.now().isoformat(),
        json.dumps(student_profile),
        scholarship.get('scholarship_id', ''),
        scholarship.get('scholarship_title', ''),
        scholarship.get('win_probability', 0),
        scholarship.get('confidence', 0),
        feedback_action,
        feedback_reason,
        comments
    ))
    
    conn.commit()
    conn.close()

# ============================================================================
# BACKEND TRANSFORMATION LAYER
# ============================================================================

def normalize_student_profile(raw_input):
    """
    Transform user-friendly form input into backend-compatible student profile.
    This is the canonical transformation layer.
    """
    
    # Map degree level to binary flags
    degree_level = raw_input.get('degree_level', 'Undergraduate')
    is_bachelor = 1 if degree_level == 'Undergraduate' else 0
    is_master = 1 if degree_level == "Master's" else 0
    is_phd = 1 if degree_level == 'PhD' else 0
    
    # Map gender to binary flags
    gender = raw_input.get('gender', 'Prefer not to say')
    is_female = 1 if gender == 'Female' else 0
    is_male = 1 if gender == 'Male' else 0
    
    # Map financial need
    need_mapping = {
        'High need': 'high_need',
        'Medium need': 'medium_need',
        'Low need': 'low_need',
        'Prefer not to say': 'unknown'
    }
    financial_need_level = need_mapping.get(raw_input.get('financial_need', 'unknown'), 'unknown')
    
    # Create normalized profile
    normalized = {
        'current_cgpa': raw_input.get('cgpa', 3.0),
        'program': raw_input.get('field_of_study', 'Unknown'),
        'interest_area': raw_input.get('interests', ''),
        'skills': raw_input.get('skills', ''),
        'is_bachelor': is_bachelor,
        'is_master': is_master,
        'is_phd': is_phd,
        'is_female': is_female,
        'is_male': is_male,
        'financial_need_level': financial_need_level,
        'country': raw_input.get('country', 'Unknown'),
        
        # Special eligibility (checkboxes)
        'first_generation': raw_input.get('first_generation', False),
        'minority': raw_input.get('minority', False),
        'disability': raw_input.get('disability', False),
        'veteran': raw_input.get('veteran', False)
    }
    
    return normalized

# ============================================================================
# LOAD MATCHING ENGINE AND DATA
# ============================================================================

@st.cache_data
def load_scholarships():
    """Load preprocessed scholarship dataset"""
    try:
        df = pd.read_csv('scholarships_final_ready.csv')
        return df
    except FileNotFoundError:
        st.error("âš ï¸ Scholarship dataset not found. Please ensure 'scholarships_final_ready.csv' is in the same directory.")
        return None

# ============================================================================
# SESSION STATE MANAGEMENT
# ============================================================================

if 'page' not in st.session_state:
    st.session_state.page = 'landing'
if 'student_profile' not in st.session_state:
    st.session_state.student_profile = None
if 'recommendations' not in st.session_state:
    st.session_state.recommendations = None
if 'feedback_submitted' not in st.session_state:
    st.session_state.feedback_submitted = {}
if 'show_analytics' not in st.session_state:
    st.session_state.show_analytics = False

# ============================================================================
# ANALYTICS DASHBOARD (ADMIN VIEW)
# ============================================================================

def get_analytics_data():
    """Fetch analytics from database"""
    conn = sqlite3.connect('scholarMatch_feedback.db')
    
    # Get all feedback
    feedback_df = pd.read_sql_query("SELECT * FROM feedback", conn)
    
    conn.close()
    return feedback_df

def analytics_dashboard():
    """Admin analytics dashboard"""
    
    st.title("ğŸ“Š Analytics Dashboard")
    st.markdown("System performance and user feedback insights")
    
    # Fetch data
    feedback_df = get_analytics_data()
    
    if len(feedback_df) == 0:
        st.info("No feedback data yet. Start collecting user responses!")
        if st.button("â† Back to App"):
            st.session_state.show_analytics = False
            st.rerun()
        return
    
    # Overview Metrics
    st.subheader("ğŸ“ˆ Overview")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_users = feedback_df['student_profile'].nunique()
        st.metric("Total Users", total_users)
    
    with col2:
        total_feedback = len(feedback_df)
        st.metric("Total Feedback", total_feedback)
    
    with col3:
        avg_feedback_per_user = total_feedback / total_users if total_users > 0 else 0
        st.metric("Avg Feedback/User", f"{avg_feedback_per_user:.1f}")
    
    with col4:
        applied_count = len(feedback_df[feedback_df['feedback_action'] == 'ğŸ“ Applied/Will apply'])
        st.metric("Applications", applied_count)
    
    st.markdown("---")
    
    # Feedback Distribution
    st.subheader("ğŸ’¬ Feedback Distribution")
    
    feedback_counts = feedback_df['feedback_action'].value_counts()
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.bar_chart(feedback_counts)
    
    with col2:
        for action, count in feedback_counts.items():
            percentage = (count / len(feedback_df)) * 100
            st.write(f"**{action}:** {count} ({percentage:.1f}%)")
    
    st.markdown("---")
    
    # Top Scholarships by Engagement
    st.subheader("ğŸ† Top Scholarships by Feedback")
    
    top_scholarships = feedback_df.groupby('scholarship_title').agg({
        'feedback_action': 'count',
        'win_probability': 'mean',
        'confidence': 'mean'
    }).rename(columns={
        'feedback_action': 'feedback_count'
    }).sort_values('feedback_count', ascending=False).head(10)
    
    st.dataframe(top_scholarships, use_container_width=True)
    
    st.markdown("---")
    
    # "Not Eligible" Reasons (Gold for improving system)
    st.subheader("âš ï¸ Common 'Not Eligible' Reasons")
    
    not_eligible = feedback_df[feedback_df['feedback_action'] == 'âŒ Not eligible']
    
    if len(not_eligible) > 0:
        reasons = not_eligible['feedback_reason'].dropna()
        if len(reasons) > 0:
            st.write(f"**Total 'Not Eligible' responses:** {len(not_eligible)}")
            st.write("**Sample reasons:**")
            for idx, reason in enumerate(reasons.head(10), 1):
                st.write(f"{idx}. {reason}")
        else:
            st.info("No reasons provided yet")
    else:
        st.info("No 'Not Eligible' feedback yet")
    
    st.markdown("---")
    
    # Export Data
    st.subheader("ğŸ“¥ Export Data")
    
    csv = feedback_df.to_csv(index=False)
    st.download_button(
        label="Download All Feedback as CSV",
        data=csv,
        file_name=f"scholarMatch_feedback_{datetime.now().strftime('%Y%m%d')}.csv",
        mime="text/csv"
    )
    
    st.markdown("---")
    
    if st.button("â† Back to App"):
        st.session_state.show_analytics = False
        st.rerun()

# ============================================================================
# PAGE 1: LANDING PAGE
# ============================================================================

def landing_page():
    """Landing page with intro and call-to-action"""
    
    st.title("ğŸ“ OptiScholar")
    st.subheader("Find scholarships that match YOUR profile")
    
    st.markdown("""
    ### How it works:
    
    1. **Tell us about yourself** - Quick 2-minute profile
    2. **Get personalized recommendations** - See your top scholarship matches
    3. **Understand why** - Clear explanations for each recommendation
    4. **Help us improve** - Share quick feedback
    
    Our system analyzes 11,000+ scholarships to find the best matches for you.
    """)
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("ğŸš€ Get Started", use_container_width=True, type="primary"):
            st.session_state.page = 'profile'
            st.rerun()
    
    st.markdown("---")
    
    # Analytics access (hidden link)
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("ğŸ“Š View Analytics (Admin)", use_container_width=True):
            st.session_state.show_analytics = True
            st.rerun()
    
    st.markdown("---")
    st.caption("ğŸ’¡ Your data is collected anonymously to improve recommendations.")

# ============================================================================
# PAGE 2: STUDENT PROFILE FORM
# ============================================================================

def profile_form_page():
    """Student profile input form"""
    
    st.title("ğŸ“ Your Profile")
    st.markdown("Help us understand you better to find the perfect scholarships.")
    
    # Back to home button
    if st.button("ğŸ  Back to Home"):
        st.session_state.page = 'landing'
        st.rerun()
    
    st.markdown("---")
    
    with st.form("student_profile_form"):
        
        # Personal Info (Optional)
        st.subheader("Personal Information (Optional)")
        col1, col2 = st.columns(2)
        with col1:
            name = st.text_input("Full Name", placeholder="e.g., John Doe")
        with col2:
            email = st.text_input("Email", placeholder="e.g., john@example.com")
        
        st.markdown("---")
        
        # Academic Info
        st.subheader("Academic Information")
        
        col1, col2 = st.columns(2)
        with col1:
            cgpa = st.slider("Current CGPA", 0.0, 4.0, 3.0, 0.05)
        with col2:
            degree_level = st.selectbox(
                "Degree Level",
                ["Undergraduate", "Master's", "PhD"]
            )
        
        field_of_study = st.text_input(
            "Field of Study",
            placeholder="e.g., Computer Science, Engineering, Business"
        )
        
        st.markdown("---")
        
        # Background
        st.subheader("Background")
        
        col1, col2 = st.columns(2)
        with col1:
            gender = st.selectbox("Gender", ["Female", "Male", "Prefer not to say"])
        with col2:
            country = st.selectbox(
                "Country of Citizenship",
                [
                    "United States", "Canada", "United Kingdom", "India", 
                    "China", "Germany", "France", "Australia", "Japan",
                    "South Korea", "Brazil", "Mexico", "Italy", "Spain",
                    "Netherlands", "Sweden", "Norway", "Denmark", "Finland",
                    "Singapore", "Pakistan", "Bangladesh", "Nigeria", "Egypt",
                    "South Africa", "Kenya", "Other"
                ]
            )
        
        st.markdown("---")
        
        # Interests & Skills
        st.subheader("Interests & Skills")
        
        interests = st.text_input(
            "Areas of Interest",
            placeholder="e.g., Machine Learning, Data Science, Web Development"
        )
        
        skills = st.text_input(
            "Skills",
            placeholder="e.g., Python, Research, Leadership, Communication"
        )
        
        st.markdown("---")
        
        # Financial
        st.subheader("Financial Information")
        
        financial_need = st.selectbox(
            "Financial Need Level",
            ["High need", "Medium need", "Low need", "Prefer not to say"]
        )
        
        st.markdown("---")
        
        # Special Eligibility
        st.subheader("Special Eligibility (Optional)")
        
        col1, col2 = st.columns(2)
        with col1:
            first_gen = st.checkbox("First-generation student")
            minority = st.checkbox("Minority student")
        with col2:
            disability = st.checkbox("Have a disability")
            veteran = st.checkbox("Veteran or veteran's child")
        
        st.markdown("---")
        
        # Submit button
        col1, col2, col3 = st.columns([1, 1, 1])
        with col2:
            submitted = st.form_submit_button("ğŸ” Find Scholarships", use_container_width=True, type="primary")
        
        if submitted:
            # Validate required fields
            if cgpa and field_of_study:
                # Store raw input
                raw_profile = {
                    'name': name,
                    'email': email,
                    'cgpa': cgpa,
                    'degree_level': degree_level,
                    'field_of_study': field_of_study,
                    'gender': gender,
                    'country': country,
                    'interests': interests,
                    'skills': skills,
                    'financial_need': financial_need,
                    'first_generation': first_gen,
                    'minority': minority,
                    'disability': disability,
                    'veteran': veteran
                }
                
                # Transform to backend format
                st.session_state.student_profile = normalize_student_profile(raw_profile)
                st.session_state.raw_profile = raw_profile  # Keep for display
                
                # Move to results page
                st.session_state.page = 'results'
                st.rerun()
            else:
                st.error("Please fill in CGPA and Field of Study")

# ============================================================================
# PAGE 3: RESULTS PAGE
# ============================================================================

def results_page():
    """Display scholarship recommendations"""
    
    # Load scholarships
    scholarships_df = load_scholarships()
    if scholarships_df is None:
        st.error("Could not load scholarships database")
        return
    
    # Get student profile
    student = st.session_state.student_profile
    student_name = st.session_state.raw_profile.get('name', '')
    
    # Generate recommendations
    with st.spinner('ğŸ” Analyzing 11,000+ scholarships...'):
        recommendations = recommend_scholarships(student, scholarships_df, top_k=10)
    
    # Display results
    st.title("ğŸ¯ Your Top Scholarship Matches")
    
    if student_name:
        st.subheader(f"Personalized for {student_name}")
    
    raw = st.session_state.raw_profile
    st.markdown(f"**Your CGPA:** {student['current_cgpa']:.2f} | **Field:** {raw['field_of_study']} | **Level:** {raw['degree_level']}")
    
    # Show total eligible count
    if len(recommendations) > 0:
        st.success(f"âœ… Found {len(recommendations)} scholarships you're eligible for!")
    else:
        st.warning("âš ï¸ No scholarships found matching your profile. Try adjusting your criteria.")
        if st.button("ğŸ”„ Start New Search"):
            st.session_state.page = 'profile'
            st.rerun()
        return
    
    st.markdown("---")
    
    # Display recommendations
    st.markdown("### ğŸ† Top Matches")
    
    for idx, row in recommendations.iterrows():
        rank = idx + 1
        
        with st.expander(
            f"**{rank}. {row['scholarship_title']}** â€” Final Score: {row['final_score']:.1f}/100",
            expanded=(rank <= 3)
        ):
            col1, col2 = st.columns([2, 1])
            
            with col1:
                # Score breakdown
                st.markdown(f"""
                **ğŸ“Š Match Analysis:**
                - **Win Probability:** {row['win_probability']:.1f}%
                - **Confidence:** {row['confidence']:.1f}%
                
                **ğŸ’° Funding:** {row['funding_amount']} ({row['funding_category']})  
                **ğŸ“… Deadline:** {row['deadline']} [{row['deadline_urgency']}]
                
                **âœ… Why You Match:**  
                {row['reasons']}
                
                **ğŸ”— [View Full Scholarship Details]({row['link']})**
                
                ---
                
                **ğŸ“ˆ Detailed Score Breakdown:**
                """)
                
                # Score details - no nested expander
                score_col1, score_col2 = st.columns(2)
                with score_col1:
                    st.metric("GPA Match", f"{row['gpa_score']:.1f}/100")
                    st.metric("Field Alignment", f"{row['field_score']:.1f}/100")
                with score_col2:
                    st.metric("Special Eligibility", f"+{row['special_score']}")
                    st.metric("Financial Need", f"{row['need_score']:.1f}/100")
            
            with col2:
                st.markdown("**ğŸ“ Your Feedback:**")
                
                feedback_key = f"feedback_{row['scholarship_id']}"
                
                if feedback_key not in st.session_state.feedback_submitted:
                    feedback_action = st.radio(
                        "What did you do?",
                        [
                            "ğŸ‘€ Looks relevant",
                            "â­ Saved/Bookmarked",
                            "ğŸ“ Applied/Will apply",
                            "âŒ Not eligible",
                            "ğŸ¤” Not sure"
                        ],
                        key=f"radio_{rank}",
                        label_visibility="collapsed"
                    )
                    
                    # Optional reason for "Not eligible"
                    feedback_reason = None
                    if feedback_action == "âŒ Not eligible":
                        feedback_reason = st.text_input(
                            "Why not eligible?",
                            key=f"reason_{rank}",
                            placeholder="e.g., Requires US citizenship"
                        )
                    
                    if st.button("Submit Feedback", key=f"submit_{rank}", type="primary"):
                        # Convert scholarship row to dict
                        scholarship_dict = row.to_dict()
                        
                        # Save feedback
                        save_feedback(
                            student_profile=student,
                            scholarship=scholarship_dict,
                            feedback_action=feedback_action,
                            feedback_reason=feedback_reason
                        )
                        
                        st.session_state.feedback_submitted[feedback_key] = {
                            'action': feedback_action,
                            'reason': feedback_reason
                        }
                        st.success("âœ“ Feedback submitted!")
                        st.rerun()
                else:
                    submitted = st.session_state.feedback_submitted[feedback_key]
                    st.success(f"âœ… {submitted['action']}")
                    if submitted['reason']:
                        st.caption(f"Reason: {submitted['reason']}")
    
    st.markdown("---")
    
    # Actions
    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("ğŸ  Back to Home", use_container_width=True):
            st.session_state.page = 'landing'
            st.session_state.feedback_submitted = {}
            st.rerun()
    
    with col2:
        if st.button("ğŸ”„ New Search", use_container_width=True):
            st.session_state.page = 'profile'
            st.session_state.feedback_submitted = {}
            st.rerun()
    
    with col3:
        # Export results as CSV
        csv = recommendations.to_csv(index=False)
        st.download_button(
            label="ğŸ“¥ Download Results",
            data=csv,
            file_name=f"scholarships_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv",
            use_container_width=True
        )

# ============================================================================
# MAIN APP ROUTER
# ============================================================================

def main():
    """Main app logic"""
    
    # Initialize database
    init_database()
    
    # Check if showing analytics
    if st.session_state.show_analytics:
        analytics_dashboard()
        return
    
    # Route to appropriate page
    if st.session_state.page == 'landing':
        landing_page()
    elif st.session_state.page == 'profile':
        profile_form_page()
    elif st.session_state.page == 'results':
        results_page()

if __name__ == "__main__":
    main()
